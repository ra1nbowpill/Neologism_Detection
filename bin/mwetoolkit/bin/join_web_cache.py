#!/usr/bin/python
# -*- coding:UTF-8 -*-

################################################################################
#
# Copyright 2010-2014 Carlos Ramisch, Vitor De Araujo, Silvio Ricardo Cordeiro,
# Sandra Castellanos
#
# join_web_cache.py is part of mwetoolkit
#
# mwetoolkit is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# mwetoolkit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with mwetoolkit.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
"""
    This script joins two web frequency cache files. These files are generated
    by counter.py and store the Google or Yahoo word and ngram counts. If two
    cache entries have the same value, the newest one is kept. Joining cache
    files from Yahoo and from Google in a single file is not recommended since
    these two search engines have different index sizes and counts.
    
    For more information, call the script with no parameter and read the
    usage instructions.
"""

from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import absolute_import

import cPickle

from libs.util import read_options, treat_options_simplest, verbose
                 
#from base.__common import TEMP_PREFIX, TEMP_FOLDER
     
################################################################################     
# GLOBALS     
     
usage_string = """Usage: 
    
python {program} OPTIONS <cache1.dat> <cache2.dat> <cache_out.dat>

OPTIONS may be:

{common_options}

    The <cache*.dat> files must be generated by counter.py, and should be
    different from each other.
"""       

################################################################################

def combine_caches( cache1, cache2, cache_out ) :
    """
        Given two web caches, generates a third one which is the union of the
        first two. If a key is contained in both caches, then the value of the
        most recent one is kept and the oldest is discarded. If they are both
        from the same date, the value from cache1 is kept.
    """    
    # First, copy all entries from cache1 to cache_out
    for k1 in cache1.keys() :
        cache_out[ k1 ] = cache1[ k1 ]   
    # Update entries in cache_out if corresponding entry in cache_2 is newer
    for k2 in cache2.keys() :        
        ( freq2, date2 ) = cache2[ k2 ]
        ( freq_out, date_out ) = cache_out.get( k2, ( -1, None ) )
        if date_out is None :
            cache_out[ k2 ] = ( freq2, date2 )
        elif date2 < date_out :
            cache_out[ k2 ] = ( freq2, date2 )

################################################################################     
# MAIN SCRIPT

longopts = []
arg = read_options( "", longopts, treat_options_simplest, 3, usage_string )

verbose( "Opening files and checking consistency" )
cache1_desc = open( arg[ 0 ], "r" )
cache2_desc = open( arg[ 1 ], "r" )
cache_out_desc = open( arg[ 2 ], "w" )
cache1 = cPickle.load( cache1_desc )
cache2 = cPickle.load( cache2_desc )
cache_out = {}
verbose( "Combining cache files..." )
combine_caches( cache1, cache2, cache_out )
verbose( "Writing new cache file..." )
cPickle.dump( cache_out, cache_out_desc )
verbose( "{c} had {n} entries".format(c=arg[ 0 ], n=len(cache1)) )
verbose( "{c} had {n} entries".format(c=arg[ 1 ], n=len(cache2)) )
verbose( "Result has {n} entries".format(n=len(cache_out)) )
